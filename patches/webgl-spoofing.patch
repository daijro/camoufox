diff --git a/dom/base/WebGLParamsManager.cpp b/dom/base/WebGLParamsManager.cpp
new file mode 100644
index 0000000000..abcdef1234
--- /dev/null
+++ b/dom/base/WebGLParamsManager.cpp
@@ -0,0 +1,72 @@
+/* Camoufox: Per-context WebGL parameter manager */
+#include "WebGLParamsManager.h"
+
+#include "mozilla/dom/BrowsingContext.h"
+#include "nsGlobalWindowInner.h"
+#include "xpcpublic.h"
+
+namespace mozilla {
+namespace dom {
+
+nsString WebGLParamsManager::DisabledKeyForUserContext(uint32_t aId) {
+  nsAutoString key;
+  key.AppendPrintf("webgl_d_%u", aId);
+  return key;
+}
+
+void WebGLParamsManager::SetVendor(uint32_t aId, const nsAString& aValue) {
+  nsAutoString key;
+  key.AppendPrintf("webgl_vendor_%u", aId);
+  RoverfoxStorageManager::PutString(key, aValue);
+}
+
+bool WebGLParamsManager::GetVendor(uint32_t aId, nsAString& aOut) {
+  nsAutoString key;
+  key.AppendPrintf("webgl_vendor_%u", aId);
+  return RoverfoxStorageManager::GetString(key, aOut);
+}
+
+void WebGLParamsManager::SetRenderer(uint32_t aId, const nsAString& aValue) {
+  nsAutoString key;
+  key.AppendPrintf("webgl_renderer_%u", aId);
+  RoverfoxStorageManager::PutString(key, aValue);
+}
+
+bool WebGLParamsManager::GetRenderer(uint32_t aId, nsAString& aOut) {
+  nsAutoString key;
+  key.AppendPrintf("webgl_renderer_%u", aId);
+  return RoverfoxStorageManager::GetString(key, aOut);
+}
+
+void WebGLParamsManager::DisableFunction(uint32_t aId) {
+  RoverfoxStorageManager::PutBool(DisabledKeyForUserContext(aId), true);
+}
+
+bool WebGLParamsManager::IsVendorFunctionEnabledForWebIDL(JSContext* aCx,
+                                                           JSObject* aObj) {
+  nsGlobalWindowInner* win = xpc::WindowOrNull(aObj);
+  if (!win) return false;
+  uint32_t id = 0;
+  if (BrowsingContext* bc = win->GetBrowsingContext()) {
+    id = bc->OriginAttributesRef().mUserContextId;
+  }
+  bool disabled = false;
+  RoverfoxStorageManager::GetBool(DisabledKeyForUserContext(id), disabled);
+  return !disabled;
+}
+
+bool WebGLParamsManager::IsRendererFunctionEnabledForWebIDL(JSContext* aCx,
+                                                             JSObject* aObj) {
+  nsGlobalWindowInner* win = xpc::WindowOrNull(aObj);
+  if (!win) return false;
+  uint32_t id = 0;
+  if (BrowsingContext* bc = win->GetBrowsingContext()) {
+    id = bc->OriginAttributesRef().mUserContextId;
+  }
+  bool disabled = false;
+  RoverfoxStorageManager::GetBool(DisabledKeyForUserContext(id), disabled);
+  return !disabled;
+}
+
+}  // namespace dom
+}  // namespace mozilla
diff --git a/dom/base/WebGLParamsManager.h b/dom/base/WebGLParamsManager.h
new file mode 100644
index 0000000000..bcdef12345
--- /dev/null
+++ b/dom/base/WebGLParamsManager.h
@@ -0,0 +1,30 @@
+/* Camoufox: Per-context WebGL parameter manager */
+#ifndef mozilla_dom_WebGLParamsManager_h
+#define mozilla_dom_WebGLParamsManager_h
+
+#include "nsString.h"
+#include "nsTHashMap.h"
+#include "nsHashKeys.h"
+#include "RoverfoxStorageManager.h"
+
+namespace mozilla {
+namespace dom {
+
+class WebGLParamsManager {
+ public:
+  static void SetVendor(uint32_t aId, const nsAString& aValue);
+  static bool GetVendor(uint32_t aId, nsAString& aOut);
+  static void SetRenderer(uint32_t aId, const nsAString& aValue);
+  static bool GetRenderer(uint32_t aId, nsAString& aOut);
+  static void DisableFunction(uint32_t aId);
+  static bool IsVendorFunctionEnabledForWebIDL(JSContext* aCx, JSObject* aObj);
+  static bool IsRendererFunctionEnabledForWebIDL(JSContext* aCx,
+                                                  JSObject* aObj);
+ private:
+  static nsString DisabledKeyForUserContext(uint32_t aId);
+};
+
+}  // namespace dom
+}  // namespace mozilla
+
+#endif  // mozilla_dom_WebGLParamsManager_h
diff --git a/dom/base/moz.build b/dom/base/moz.build
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/base/moz.build
+++ b/dom/base/moz.build
@@ -534,5 +534,13 @@
     "nsPluginArray.cpp",
 ]

+# WebGLParamsManager compiled separately to avoid unified build scope issues
+# (includes RoverfoxStorageManager.h which can affect compilation units)
+SOURCES += ["WebGLParamsManager.cpp"]
+
+EXPORTS.mozilla.dom += [
+    "WebGLParamsManager.h",
+]
+
 # Are we targeting x86-32 or x86-64?  If so, we want to include SSE2 code for
 # CharacterDataBuffer.cpp
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -27,3 +27,4 @@
 #include "VRManagerChild.h"
+#include "WebGLParamsManager.h"
 #include "WindowDestroyedEvent.h"
 #include "WindowNamedPropertiesHandler.h"
@@ -7477,6 +7478,38 @@
   mSharedWorkers.RemoveElement(aSharedWorker);
 }

+void nsGlobalWindowInner::SetWebGLVendor(const nsAString& vendor,
+                                          ErrorResult& aRv) {
+  uint32_t userContextId = 0;
+  if (BrowsingContext* bc = GetBrowsingContext()) {
+    userContextId = bc->OriginAttributesRef().mUserContextId;
+  }
+  WebGLParamsManager::SetVendor(userContextId, vendor);
+  WebGLParamsManager::DisableFunction(userContextId);
+  if (JSContext* cx = nsContentUtils::GetCurrentJSContext()) {
+    JS::Rooted<JSObject*> global(cx, JS::CurrentGlobalOrNull(cx));
+    if (global) {
+      JS_DeleteProperty(cx, global, "setWebGLVendor");
+    }
+  }
+}
+
+void nsGlobalWindowInner::SetWebGLRenderer(const nsAString& renderer,
+                                            ErrorResult& aRv) {
+  uint32_t userContextId = 0;
+  if (BrowsingContext* bc = GetBrowsingContext()) {
+    userContextId = bc->OriginAttributesRef().mUserContextId;
+  }
+  WebGLParamsManager::SetRenderer(userContextId, renderer);
+  WebGLParamsManager::DisableFunction(userContextId);
+  if (JSContext* cx = nsContentUtils::GetCurrentJSContext()) {
+    JS::Rooted<JSObject*> global(cx, JS::CurrentGlobalOrNull(cx));
+    if (global) {
+      JS_DeleteProperty(cx, global, "setWebGLRenderer");
+    }
+  }
+}
+
 RefPtr<GenericPromise> nsGlobalWindowInner::StorageAccessPermissionChanged(
     bool aGranted) {
   // Invalidate cached StorageAllowed field so that calls to GetLocalStorage
diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -685,6 +685,10 @@

   void ForgetSharedWorker(mozilla::dom::SharedWorker* aSharedWorker);

+  // Per-context WebGL parameter spoofing
+  void SetWebGLVendor(const nsAString& vendor, mozilla::ErrorResult& aRv);
+  void SetWebGLRenderer(const nsAString& renderer, mozilla::ErrorResult& aRv);
+
  public:
   void Alert(nsIPrincipal& aSubjectPrincipal, mozilla::ErrorResult& aError);
   void Alert(const nsAString& aMessage, nsIPrincipal& aSubjectPrincipal,
diff --git a/dom/canvas/ClientWebGLContext.h b/dom/canvas/ClientWebGLContext.h
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/canvas/ClientWebGLContext.h
+++ b/dom/canvas/ClientWebGLContext.h
@@ -1083,6 +1083,11 @@ class ClientWebGLContext final : public nsICanvasRenderingContextInternal,
   void GetContextAttributes(dom::Nullable<dom::WebGLContextAttributes>& retval);

  private:
+  // Helper for mask config values
+  bool MBoolVal(const std::string& key, bool defaultValue);
+  // Per-context WebGL parameter support
+  uint32_t GetUserContextId() const;
+
   webgl::SwapChainOptions PrepareAsyncSwapChainOptions(
       WebGLFramebufferJS* fb, bool webvr,
       const webgl::SwapChainOptions& options = webgl::SwapChainOptions());
diff --git a/dom/canvas/ClientWebGLContext.cpp b/dom/canvas/ClientWebGLContext.cpp
index 11578f425f..6c77acd7f3 100644
--- a/dom/canvas/ClientWebGLContext.cpp
+++ b/dom/canvas/ClientWebGLContext.cpp
@@ -4,6 +4,13 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

 #include "ClientWebGLContext.h"
+#include "MaskConfig.hpp"
+#include "WebGLParamsManager.h"
+#include "mozilla/dom/BrowsingContext.h"
+#include "mozilla/dom/Document.h"
+#include "nsPIDOMWindow.h"
+#include <algorithm>
+#include <cstddef>

 #include <fmt/format.h>

@@ -754,6 +760,33 @@ void ClientWebGLContext::SetUnpackColorSpace(
   Run<RPROC(SetUnpackColorSpace)>(*mUnpackColorSpace);
 }

+bool ClientWebGLContext::MBoolVal(const std::string& key, bool defaultValue) {
+  if (auto value = MaskConfig::GetAttribute<bool>(key, mIsWebGL2);
+      value.has_value())
+    return value.value();
+  return defaultValue;
+}
+
+uint32_t ClientWebGLContext::GetUserContextId() const {
+  if (mCanvasElement) {
+    if (Document* doc = mCanvasElement->OwnerDoc()) {
+      if (BrowsingContext* bc = doc->GetBrowsingContext()) {
+        return bc->OriginAttributesRef().mUserContextId;
+      }
+    }
+  } else if (mOffscreenCanvas) {
+    if (nsIGlobalObject* global = mOffscreenCanvas->GetOwnerGlobal()) {
+      nsCOMPtr<nsPIDOMWindowInner> win = do_QueryInterface(global);
+      if (win) {
+        if (BrowsingContext* bc = win->GetBrowsingContext()) {
+          return bc->OriginAttributesRef().mUserContextId;
+        }
+      }
+    }
+  }
+  return 0;
+}
+
 void ClientWebGLContext::GetContextAttributes(
     dom::Nullable<dom::WebGLContextAttributes>& retval) {
   retval.SetNull();
@@ -764,15 +787,40 @@ void ClientWebGLContext::GetContextAttributes(

   const auto& options = mNotLost->info.options;

-  result.mAlpha.Construct(options.alpha);
-  result.mDepth = options.depth;
-  result.mStencil = options.stencil;
-  result.mAntialias.Construct(options.antialias);
-  result.mPremultipliedAlpha = options.premultipliedAlpha;
-  result.mPreserveDrawingBuffer = options.preserveDrawingBuffer;
-  result.mFailIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
-  result.mPowerPreference = options.powerPreference;
-  result.mForceSoftwareRendering = options.forceSoftwareRendering;
+  result.mAlpha.Construct(MBoolVal("alpha", options.alpha));
+  result.mDepth = MBoolVal("depth", options.depth);
+  result.mStencil = MBoolVal("stencil", options.stencil);
+  result.mAntialias.Construct(MBoolVal("antialias", options.antialias));
+  result.mPremultipliedAlpha = MBoolVal(
+      "webGl:contextAttributes.premultipliedAlpha", options.premultipliedAlpha);
+  result.mPreserveDrawingBuffer =
+      MBoolVal("preserveDrawingBuffer", options.preserveDrawingBuffer);
+  result.mFailIfMajorPerformanceCaveat = MBoolVal(
+      "failIfMajorPerformanceCaveat", options.failIfMajorPerformanceCaveat);
+  if (auto value =
+          MaskConfig::GetAttribute<std::string>("powerPreference", mIsWebGL2);
+      value.has_value()) {
+    // Convert to enum
+    switch (value.value()[0]) {
+      case 'd':
+        result.mPowerPreference = dom::WebGLPowerPreference::Default;
+        break;
+      case 'l':
+        result.mPowerPreference = dom::WebGLPowerPreference::Low_power;
+        break;
+      case 'h':
+        result.mPowerPreference = dom::WebGLPowerPreference::High_performance;
+        break;
+      default:
+        // Invalid value
+        result.mPowerPreference = options.powerPreference;
+        break;
+    }
+  } else {
+    result.mPowerPreference = options.powerPreference;
+  }
+  result.mForceSoftwareRendering = MBoolVal(
+      "forceSoftwareRendering", options.forceSoftwareRendering);
 }

 // -----------------------
@@ -991,18 +1039,28 @@ bool ClientWebGLContext::CreateHostContext(const uvec2& requestedSize) {
 std::unordered_map<GLenum, bool> webgl::MakeIsEnabledMap(const bool webgl2) {
   auto ret = std::unordered_map<GLenum, bool>{};

-  ret[LOCAL_GL_BLEND] = false;
-  ret[LOCAL_GL_CULL_FACE] = false;
-  ret[LOCAL_GL_DEPTH_TEST] = false;
-  ret[LOCAL_GL_DITHER] = true;
-  ret[LOCAL_GL_POLYGON_OFFSET_FILL] = false;
-  ret[LOCAL_GL_SAMPLE_ALPHA_TO_COVERAGE] = false;
-  ret[LOCAL_GL_SAMPLE_COVERAGE] = false;
-  ret[LOCAL_GL_SCISSOR_TEST] = false;
-  ret[LOCAL_GL_STENCIL_TEST] = false;
+  ret[LOCAL_GL_BLEND] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_BLEND, false, webgl2);
+  ret[LOCAL_GL_CULL_FACE] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_CULL_FACE, false, webgl2);
+  ret[LOCAL_GL_DEPTH_TEST] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_DEPTH_TEST, false, webgl2);
+  ret[LOCAL_GL_DITHER] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_DITHER, true, webgl2);
+  ret[LOCAL_GL_POLYGON_OFFSET_FILL] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_POLYGON_OFFSET_FILL, false, webgl2);
+  ret[LOCAL_GL_SAMPLE_ALPHA_TO_COVERAGE] = MaskConfig::MParamGL<bool>(
+      LOCAL_GL_SAMPLE_ALPHA_TO_COVERAGE, false, webgl2);
+  ret[LOCAL_GL_SAMPLE_COVERAGE] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_SAMPLE_COVERAGE, false, webgl2);
+  ret[LOCAL_GL_SCISSOR_TEST] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_SCISSOR_TEST, false, webgl2);
+  ret[LOCAL_GL_STENCIL_TEST] =
+      MaskConfig::MParamGL<bool>(LOCAL_GL_STENCIL_TEST, false, webgl2);

   if (webgl2) {
-    ret[LOCAL_GL_RASTERIZER_DISCARD] = false;
+    ret[LOCAL_GL_RASTERIZER_DISCARD] =
+        MaskConfig::MParamGL<bool>(LOCAL_GL_RASTERIZER_DISCARD, false, webgl2);
   }

   return ret;
@@ -2114,6 +2172,57 @@ void ClientWebGLContext::GetParameter(JSContext* cx, GLenum pname,
   const auto& state = State();

   // -
+  std::optional<
+      std::variant<int64_t, bool, double, std::string, std::nullptr_t>>
+      data;
+  data = MaskConfig::GLParam(pname, mIsWebGL2);
+
+  if (data.has_value()) {
+    const auto& value = data.value();
+    if (std::holds_alternative<int64_t>(value)) {
+      retval.set(JS::NumberValue(double(std::get<int64_t>(value))));
+      return;
+    }
+    if (std::holds_alternative<double>(value)) {
+      retval.set(JS::NumberValue(std::get<double>(value)));
+      return;
+    }
+    if (std::holds_alternative<bool>(value)) {
+      retval.set(JS::BooleanValue(std::get<bool>(value)));
+      return;
+    }
+    if (std::holds_alternative<std::string>(value)) {
+      retval.set(StringValue(cx, std::get<std::string>(value), rv));
+      return;
+    }
+    if (std::holds_alternative<std::nullptr_t>(value)) {
+      retval.set(JS::NullValue());
+      return;
+    }
+  }
+  // If the value is not array (we will handle those later),
+  // then check if it should be blocked.
+  switch (pname) {
+    case LOCAL_GL_DEPTH_RANGE:
+    case LOCAL_GL_ALIASED_POINT_SIZE_RANGE:
+    case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE:
+    case LOCAL_GL_COLOR_CLEAR_VALUE:
+    case LOCAL_GL_BLEND_COLOR:
+    case LOCAL_GL_MAX_VIEWPORT_DIMS:
+    case LOCAL_GL_SCISSOR_BOX:
+    case LOCAL_GL_VIEWPORT:
+    case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
+    case LOCAL_GL_COLOR_WRITEMASK:
+    case dom::WEBGL_debug_renderer_info_Binding::UNMASKED_RENDERER_WEBGL:
+    case dom::WEBGL_debug_renderer_info_Binding::UNMASKED_VENDOR_WEBGL:
+      break;
+    default:
+      if (MaskConfig::CheckBool(mIsWebGL2 ? "webGl2:parameters:blockIfNotDefined"
+                                          : "webGl:parameters:blockIfNotDefined")) {
+        retval.set(JS::NullValue());
+        return;
+      }
+  }

   const auto fnSetRetval_Buffer = [&](const GLenum target) {
     const auto buffer = *MaybeFind(state.mBoundBufferByTarget, target);
@@ -2219,49 +2328,84 @@ void ClientWebGLContext::GetParameter(JSContext* cx, GLenum pname,

     // 2 floats
     case LOCAL_GL_DEPTH_RANGE:
-      retval.set(Create<dom::Float32Array>(cx, this, state.mDepthRange, rv));
+      retval.set(Create<dom::Float32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<float, 2UL>>(pname, state.mDepthRange,
+                                                       mIsWebGL2),
+          rv));
       return;

     case LOCAL_GL_ALIASED_POINT_SIZE_RANGE:
-      retval.set(
-          Create<dom::Float32Array>(cx, this, limits.pointSizeRange, rv));
+      retval.set(Create<dom::Float32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<float, 2UL>>(
+              pname, limits.pointSizeRange, mIsWebGL2),
+          rv));
       return;

     case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE:
-      retval.set(
-          Create<dom::Float32Array>(cx, this, limits.lineWidthRange, rv));
+      retval.set(Create<dom::Float32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<float, 2UL>>(
+              pname, limits.lineWidthRange, mIsWebGL2),
+          rv));
       return;

     // 4 floats
     case LOCAL_GL_COLOR_CLEAR_VALUE:
-      retval.set(Create<dom::Float32Array>(cx, this, state.mClearColor, rv));
+      retval.set(Create<dom::Float32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<float, 4UL>>(pname, state.mClearColor,
+                                                       mIsWebGL2),
+          rv));
       return;

     case LOCAL_GL_BLEND_COLOR:
-      retval.set(Create<dom::Float32Array>(cx, this, state.mBlendColor, rv));
+      retval.set(Create<dom::Float32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<float, 4UL>>(pname, state.mBlendColor,
+                                                       mIsWebGL2),
+          rv));
       return;

     // 2 ints
     case LOCAL_GL_MAX_VIEWPORT_DIMS: {
       auto maxViewportDim = BitwiseCast<int32_t>(limits.maxViewportDim);
       const auto dims = std::array<int32_t, 2>{maxViewportDim, maxViewportDim};
-      retval.set(Create<dom::Int32Array>(cx, this, dims, rv));
+      retval.set(Create<dom::Int32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<int32_t, 2UL>>(pname, dims,
+                                                         mIsWebGL2),
+          rv));
       return;
     }

     // 4 ints
     case LOCAL_GL_SCISSOR_BOX:
-      retval.set(Create<dom::Int32Array>(cx, this, state.mScissor, rv));
+      retval.set(Create<dom::Int32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<int32_t, 4UL>>(pname, state.mScissor,
+                                                         mIsWebGL2),
+          rv));
       return;

     case LOCAL_GL_VIEWPORT:
-      retval.set(Create<dom::Int32Array>(cx, this, state.mViewport, rv));
+      retval.set(Create<dom::Int32Array>(
+          cx, this,
+          MaskConfig::MParamGL<std::array<int32_t, 4UL>>(pname, state.mViewport,
+                                                         mIsWebGL2),
+          rv));
       return;

-    // any
     case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
-      retval.set(Create<dom::Uint32Array>(cx, this,
-                                          state.mCompressedTextureFormats, rv));
+      std::vector<uint32_t> compressedTextureUint32(
+          state.mCompressedTextureFormats.begin(),
+          state.mCompressedTextureFormats.end());
+      retval.set(Create<dom::Uint32Array>(
+          cx, this,
+          MaskConfig::MParamGLVector<uint32_t>(pname, compressedTextureUint32,
+                                               mIsWebGL2),
+          rv));
       return;
   }

@@ -2441,6 +2585,17 @@

         switch (pname) {
           case dom::WEBGL_debug_renderer_info_Binding::UNMASKED_RENDERER_WEBGL:
+            {
+              nsAutoString stored;
+              if (WebGLParamsManager::GetRenderer(GetUserContextId(), stored)) {
+                ret = Some(NS_ConvertUTF16toUTF8(stored));
+                break;
+              }
+            }
+            if (auto value = MaskConfig::GetString("webGl:renderer")) {
+              ret = Some(value.value());
+              break;
+            }
             if (ShouldResistFingerprinting(RFPTarget::WebGLRenderInfo)) {
               ret = Some("Mozilla"_ns);
             } else {
@@ -2452,6 +2607,17 @@
             break;

           case dom::WEBGL_debug_renderer_info_Binding::UNMASKED_VENDOR_WEBGL:
+            {
+              nsAutoString stored;
+              if (WebGLParamsManager::GetVendor(GetUserContextId(), stored)) {
+                ret = Some(NS_ConvertUTF16toUTF8(stored));
+                break;
+              }
+            }
+            if (auto value = MaskConfig::GetString("webGl:vendor")) {
+              ret = Some(value.value());
+              break;
+            }
             ret = ShouldResistFingerprinting(RFPTarget::WebGLRenderInfo)
                       ? Some("Mozilla"_ns)
                       : GetUnmaskedVendor();
@@ -2545,7 +2711,9 @@ void ClientWebGLContext::GetParameter(JSContext* cx, GLenum pname,
         case LOCAL_GL_COLOR_WRITEMASK: {
           const auto mask = uint8_t(*maybe);
           const auto bs = std::bitset<4>(mask);
-          const auto src = std::array<bool, 4>{bs[0], bs[1], bs[2], bs[3]};
+          const auto src = MaskConfig::MParamGL<std::array<bool, 4>>(
+              pname, std::array<bool, 4>{bs[0], bs[1], bs[2], bs[3]},
+              mIsWebGL2);
           JS::Rooted<JS::Value> arr(cx);
           if (!dom::ToJSValue(cx, src.data(), src.size(), &arr)) {
             rv = NS_ERROR_OUT_OF_MEMORY;
@@ -2960,6 +3128,24 @@ ClientWebGLContext::GetShaderPrecisionFormat(const GLenum shadertype,
   const FuncScope funcScope(*this, "getShaderPrecisionFormat");
   if (IsContextLost()) return nullptr;

+  // Check for spoofed value
+  if (auto value =
+          MaskConfig::MShaderData(shadertype, precisiontype, mIsWebGL2)) {
+    const auto& format = value.value();
+    const auto spoofed = webgl::ShaderPrecisionFormat{
+        static_cast<uint8_t>(format[0]),  // rangeMin
+        static_cast<uint8_t>(format[1]),  // rangeMax
+        static_cast<uint8_t>(format[2])   // precision
+    };
+    return AsAddRefed(new WebGLShaderPrecisionFormatJS(spoofed));
+  }
+  // Check if block if not defined is on
+  if (MaskConfig::CheckBool(
+          mIsWebGL2 ? "webGl2:shaderPrecisionFormats:blockIfNotDefined"
+                    : "webGl:shaderPrecisionFormats:blockIfNotDefined")) {
+    return nullptr;
+  }
+
   const auto& shaderPrecisions = *notLost->info.shaderPrecisions;
   const auto args =
       webgl::GetShaderPrecisionFormatArgs{shadertype, precisiontype};
@@ -6101,6 +6287,17 @@ bool ClientWebGLContext::IsSupported(const WebGLExtensionID ext,
     return false;
   }

+  if (std::vector<std::string> maskValues =
+          MaskConfig::GetStringList(mIsWebGL2 ? "webGl2:supportedExtensions"
+                                              : "webGl:supportedExtensions");
+      !maskValues.empty()) {
+    if (std::find(maskValues.begin(), maskValues.end(),
+                  GetExtensionName(ext)) != maskValues.end()) {
+      return true;
+    }
+    return false;
+  }
+
   const auto& limits = Limits();
   return limits.supportedExtensions[ext];
 }
@@ -6112,6 +6309,18 @@ void ClientWebGLContext::GetSupportedExtensions(
   if (IsContextLost()) return;

   auto& retarr = retval.SetValue();
+
+  // Implement separately to prevent O(n^2) timing
+  if (std::vector<std::string> maskValues =
+          MaskConfig::GetStringList(mIsWebGL2 ? "webGl2:supportedExtensions"
+                                              : "webGl:supportedExtensions");
+      !maskValues.empty()) {
+    for (const auto& ext : maskValues) {
+      retarr.AppendElement(NS_ConvertUTF8toUTF16(ext));
+    }
+    return;
+  }
+
   for (const auto i : MakeEnumeratedRange(WebGLExtensionID::Max)) {
     if (!IsSupported(i, callerType)) continue;

diff --git a/dom/canvas/moz.build b/dom/canvas/moz.build
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/canvas/moz.build
+++ b/dom/canvas/moz.build
@@ -188,6 +188,9 @@ SOURCES += [
 # Suppress warnings from third-party code.
 SOURCES["MurmurHash3.cpp"].flags += ["-Wno-implicit-fallthrough"]

+LOCAL_INCLUDES += ["/camoucfg"]
+LOCAL_INCLUDES += ["/dom/base"]
+
 LOCAL_INCLUDES += [
     "/js/xpconnect/wrappers",
 ]
diff --git a/dom/webidl/Window.webidl b/dom/webidl/Window.webidl
index xxxxxxxxxx..yyyyyyyyyy 100644
--- a/dom/webidl/Window.webidl
+++ b/dom/webidl/Window.webidl
@@ -900,6 +900,18 @@
   undefined setScrollMarks(sequence<unsigned long> marks,
                            optional boolean onHorizontalScrollbar = false);
 };

+// Per-context WebGL vendor spoofing
+partial interface Window {
+  [Throws, Func="mozilla::dom::WebGLParamsManager::IsVendorFunctionEnabledForWebIDL"]
+  undefined setWebGLVendor(DOMString vendor);
+};
+
+// Per-context WebGL renderer spoofing
+partial interface Window {
+  [Throws, Func="mozilla::dom::WebGLParamsManager::IsRendererFunctionEnabledForWebIDL"]
+  undefined setWebGLRenderer(DOMString renderer);
+};
+
 dictionary WindowPostMessageOptions : StructuredSerializeOptions {
   USVString targetOrigin = "/";
 };
